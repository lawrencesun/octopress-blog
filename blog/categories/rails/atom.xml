<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Lawrence Sun]]></title>
  <link href="http://voice.lawrencesun.info/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://voice.lawrencesun.info/"/>
  <updated>2014-02-16T22:53:20+08:00</updated>
  <id>http://voice.lawrencesun.info/</id>
  <author>
    <name><![CDATA[Lawrence Sun]]></name>
    <email><![CDATA[yuliang1987@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails Notes: Pagination With Kaminari]]></title>
    <link href="http://voice.lawrencesun.info/posts/2014/02/16/rails-notes-pagination-with-kaminari/"/>
    <updated>2014-02-16T22:13:47+08:00</updated>
    <id>http://voice.lawrencesun.info/posts/2014/02/16/rails-notes-pagination-with-kaminari</id>
    <content type="html"><![CDATA[<p>With hundreds and thousands of posts on website, we would like to insert some breaks. The first choice for pagination in Rails is will_paginate. However, I find a better one called <a href="https://github.com/amatsuda/kaminari">Kaminari</a>.</p>

<!-- more -->


<p><strong>Controllers and Views</strong></p>

<p>First, add &lsquo;kaminari&rsquo; to &lsquo;Gemfile&rsquo; and run <code>bundle install</code></p>

<p>Second, we apply the scope called <code>page</code> and <code>per</code> in our Controller.</p>

<p><code>@posts = Post.all.page(params[:page]).per(15)</code></p>

<p>that will show 15 posts per each page.</p>

<p>Then, we call <code>paginate</code> helper in our views.</p>

<p><code>&lt;%= paginate @posts %&gt;</code></p>

<p><strong>Configure the default value</strong></p>

<p>run <code>rails g kaminari:config</code> and change the file <code>kaminari_config.rb</code> in config/initializers</p>

<p><code>ruby
Kaminari.configure do |config|
  config.default_per_page = 15
  # config.max_per_page = nil
  config.window = 2
  config.outer_window = 1
  # config.left = 0
  # config.right = 0
  # config.page_method_name = :page
  # config.param_name = :page
end
</code></p>

<p><strong>I18N and labels</strong></p>

<p>We can change the default labels in config/locales.</p>

<p>```ruby
en:
  views:</p>

<pre><code>pagination:
  first: "&amp;laquo; First"
  last: "Last &amp;raquo;"
  previous: "&amp;lsaquo; Prev"
  next: "Next &amp;rsaquo;"
  truncate: "..."
</code></pre>

<p>```</p>

<p><strong>Configure the default view</strong></p>

<p>run <code>rails g kaminari:views default</code> and change the files in app/views/kaminari</p>

<p>e.g. I delete the first and last label in _pagination.html.erb and change the style to bootstrap according to the theme provided by the Kaminari.</p>

<p><strong>Issue</strong></p>

<p>I followed the instruction on Railscasts and the wiki of Kaminari. But my case seemed more complicated. I set three posts per page as default for test, but found that the posts presented in a strange array.</p>

<p>PostsController:
```ruby
def index</p>

<pre><code>...
@posts = Post.all.page(params[:page])
...
</code></pre>

<p>end
```</p>

<p>index.html.erb:
<code>ruby
&lt;%= render 'shared/posts' , object: @posts%&gt;
&lt;%= paginate @posts %&gt;
</code></p>

<p>_posts.html.erb:
<code>ruby
&lt;% object.reverse.each do |post| %&gt;
</code></p>

<p>The problem was that 3 posts each time was passed into the partial and was implemented the reverse scope. So I deleted the <code>reverse</code> scope and changed the line in the controller like this:</p>

<p><code>ruby
@posts = @posts.order('created_at DESC').page(params[:page])
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Notes: Add Administrator]]></title>
    <link href="http://voice.lawrencesun.info/posts/2014/02/15/rails-notes-add-administrator/"/>
    <updated>2014-02-15T16:02:33+08:00</updated>
    <id>http://voice.lawrencesun.info/posts/2014/02/15/rails-notes-add-administrator</id>
    <content type="html"><![CDATA[<p>On the land of website/software, there is always an Administrator. The Administrator, like a king, has the right to change the rules, block the news and &lsquo;kill&rsquo; the innocent users whenever he likes.</p>

<blockquote><p>Dieu et mon droit.</p></blockquote>

<p>Today, I claimed to the throne &mdash; became an admin who had the power to delete comments and users.</p>

<!-- more -->


<p>First, <code>rails g migration add_admin_to_users</code>.</p>

<p>Second, create a table and run <code>rake db:migrate</code></p>

<p>```ruby
class AddAdminToUsers &lt; ActiveRecord::Migration
  def change</p>

<pre><code>add_column :users, :admin, :boolean, default: false
</code></pre>

<p>  end
end
```</p>

<p>Then, define a method in ApplicationController.</p>

<p>```ruby
def admin_user
  unless current_user.admin?   # line_to_be_modified</p>

<pre><code>flash[:error] = "Please contact admin."
redirect_to root_path
</code></pre>

<p>  end
end
```</p>

<p>Next, add <code>destroy</code> to UsersController</p>

<p>```ruby
&hellip;
before_action :admin_user, only: :destroy
&hellip;
def destroy</p>

<pre><code>@user.destroy
flash[:success] = "User deleted."
redirect_to users_path
</code></pre>

<p>end
```</p>

<p>Afterwards, add a delete link in the view.</p>

<p><code>ruby
&lt;%= link_to 'delete', user_path(user), method: 'delete', data: { confirm: 'You sure?'} %&gt;
</code></p>

<p>Finally, we would like to destroy the posts and comments automatically at the same time we delete the users. <code>has_many :posts, dependent: :destroy</code></p>

<hr />

<ul>
<li>Issue 1:
There would be a nil class error if there was no user signed in, <code>current_user.admin?</code> went wrong. Therefore, I added another method in ApplicationController and change the line_to_be_modified to <code>unless admin?</code></li>
</ul>


<p>```ruby
def admin?</p>

<pre><code>signed_in? &amp;&amp; current_user.admin?
</code></pre>

<p>end
```</p>

<ul>
<li>Issue 2:
Another error occurred when I tried to add the delete link on the comments partial.</li>
</ul>


<p>```ruby
&lt;% if object.comments.any? %></p>

<pre><code>&lt;% object.comments.each do |comment| %&gt;
...
&lt;% if admin? %&gt;
    &lt;%= link_to 'delete', post_comment_path($params), method: 'delete', data: { confirm: 'You sure?'} %&gt;
&lt;% end %&gt;
...
</code></pre>

<p>```</p>

<p>At first, I passed in the &lsquo;comment&rsquo; as $params, and it showed that  the post.id and :id were nil. So I changed the $params to &lsquo;comment.post.id, comment.id&rsquo; and it went well.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Notes: Markdown Support]]></title>
    <link href="http://voice.lawrencesun.info/posts/2014/02/14/rails-notes-markdown-support/"/>
    <updated>2014-02-14T12:40:02+08:00</updated>
    <id>http://voice.lawrencesun.info/posts/2014/02/14/rails-notes-markdown-support</id>
    <content type="html"><![CDATA[<p>The default output of the content in my app is directly shown as HTML. The problem is even I entered several paragraphs, it will be shown in one. On the other hand, I intend to add markdown support in the beginning. Thanks Google and Github, I found a gem called <a href="https://github.com/vmg/redcarpet">Redcarpet</a>.</p>

<p>First I found a screencast in <a href="1">Railscasts</a>. Unfortunately, this solution was introduced 2 years ago. However, I found an up-to-date one by SimplizIT below the video. Here it is.</p>

<!-- more -->


<ul>
<li><p>Install it by adding <code>gem 'redcarpet'</code> to Gemfile, and run <code>bundle install</code>.</p></li>
<li><p>Then add the following code to <code>application_helper.rb</code></p></li>
</ul>


<p>```ruby
def markdown(text)</p>

<pre><code>renderOptions = {hard_wrap: true, filter_html: true}
</code></pre>

<p>  markdownOptions = {autolink: true, fenced_code_blocks: true, no_intra_emphasis: true, strikethrough: true}</p>

<pre><code>markdown = Redcarpet::Markdown.new(Redcarpet::Render::HTML.new(renderOptions), markdownOptions)
</code></pre>

<p>  markdown.render(text).html_safe
end
```</p>

<p><sub>here, we can customise the markdown extension and html output by changing the renderOptions and markdownOptions. The full option shows <a href="1">here</a>.</sub></p>

<ul>
<li>Apply &lsquo;markdown&rsquo; function in the view template.</li>
</ul>


<p><code>&lt;%= markdown(@post.text) %&gt;</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Notes: Adding a 'Like' Function]]></title>
    <link href="http://voice.lawrencesun.info/posts/2014/02/11/rails-notes-adding-a-like-function/"/>
    <updated>2014-02-11T21:16:52+08:00</updated>
    <id>http://voice.lawrencesun.info/posts/2014/02/11/rails-notes-adding-a-like-function</id>
    <content type="html"><![CDATA[<p>Instead of text comments, we can easily state our opinion on the article by clicking a &lsquo;Like&rsquo; button or a &lsquo;Vote&rsquo; arrow. It is not uncommon that this function plays a role of recommendation. Last week, I added a similar function called &lsquo;Likeable&rsquo; to my blog-like app. Here is the key notes.</p>

<!-- more -->


<p><strong>Migration and Models</strong></p>

<p>First of all, we <code>rails g migration create_likes</code>.</p>

<p>```ruby
class CreateLikes &lt; ActiveRecord::Migration
  def up</p>

<pre><code>create_table :likes do |t|
    t.boolean :like
    t.references :likeable, polymorphic: true
    t.integer :user_id
    t.timestamps
end
</code></pre>

<p>  end</p>

<p>  def down</p>

<pre><code>drop_table :likes
</code></pre>

<p>  end
end
```</p>

<p>Here, like boolean will show the choice of like(true) or unlike(false), :user_id will show who made the choice.</p>

<p><code>t.references :likeable, polymorphic: true</code> will generate two columns: <em>likeable_id</em> and <em>likeable_type</em> (e.g. Post or Comment).</p>

<p>With <em>Polymorphic</em> association, a model can belong to more than one other model, on a single association <a href="http://guides.rubyonrails.org/association_basics.html#polymorphic-associations">[1]</a>. In our case, like model can belong to post model or comment model.</p>

<p>```ruby
class Like &lt; ActiveRecord::Base</p>

<pre><code>belongs_to :user
belongs_to :likeable, polymorphic: true.
</code></pre>

<p>end</p>

<p>class Post &lt; ActiveRecord::Base</p>

<pre><code>has_many :likes, as :likeable
</code></pre>

<p>end</p>

<p>class Comment &lt; ActiveRecord::Base</p>

<pre><code>has_many :likes, as :likeable
</code></pre>

<p>end
```</p>

<p><strong>Routes</strong></p>

<p>We would like to use a member routes here.
```ruby
resources :posts do</p>

<pre><code>member do 
    post 'like'
end
resources :comments do
    member do
        post 'like'
    end
end
</code></pre>

<p>end
```</p>

<p>It will recognise &lsquo;/post/post_id/like&rsquo; and &lsquo;/post/post_id/comment/id/like&rsquo; with POST, route to the action of PostsController and CommentsController, create the like_post_path and like_post_comment_path helpers.</p>

<p><strong>Views</strong></p>

<p>&lsquo;app/views/posts/show.html.erb&rsquo;
```ruby
<span class="pull-right"></p>

<pre><code>&lt;%= link_to like_post_path(@post, like: true), method: 'post' do %&gt;
</code></pre>

<p>  <i class="icon-thumbs-up"></i></p>

<pre><code>&lt;%= @post.likes.size %&gt;likes %&gt;
&lt;% end %&gt;
</code></pre>

<p></span>
<code>``
Here we specify the method POST instead of the default a_tag method GET, by adding</code>method: &lsquo;post&rsquo;`. This will add &lsquo;data_method=&ldquo;post&rdquo;&rsquo; to link tag, which will revoke a javascript in rails that convert the link tag to a form and submit it. We also pass in a params &lsquo;like&rsquo; to be true, which means it will count as a &lsquo;Like&rsquo;.</p>

<p>Now we need some actions.</p>

<p><strong>Action</strong></p>

<p>```ruby
class PostsController &lt; ApplicationController</p>

<pre><code>before_action :find_post, only:[…, :like]
before_action :require_user, except:[…]
…

def like
    Like.create(likeable: @post, user: current_user, like: params[:like])
    flash[:success] = "Like Counted!"
    redirect_to :back
end
</code></pre>

<p>```</p>

<p>Here, we will pass params of @post to likeable_id and likeable_type, current_user &rsquo;s id and set &lsquo;true&rsquo; on like boolean.</p>

<p><strong>Ajax</strong></p>

<p>Every time we hit the &lsquo;Thumbs-up&rsquo; button, it will hit the datebase and rebuild the whole page. It&rsquo;s quite expensive. So we will use another rails magic here.</p>

<p>Simply add <code>remote: true</code>: &lsquo;&lt;%= link_to like_post_path(@post, like: true), method: 'post&rsquo;, remote: true do %>&lsquo;. It will become a ajax request when we hit the 'Thumbs-up&rsquo;.</p>

<p>In the meantime, we add response to this request in controller, revise our show.html.erb and add a <code>like.js.erb</code> view template file in app/views/posts, respectively.</p>

<p>```ruby
def like</p>

<pre><code>    ...
respond_to do |format|
    format.html do
    flash[:success] = "Like Counted!"
    redirect_to :back
end

format.js
end         
</code></pre>

<p>end
```</p>

<p><code>ruby
&lt;span id="post_&lt;%= @post.id %&gt;_likes"&gt;&lt;%= @post.likes.size %&gt;likes&lt;/span&gt;
</code></p>

<p><code>ruby
$("#post_&lt;%= @post.id %&gt;_likes").html("&lt;%= @post.likes.size %&gt;likes");
</code></p>

<p><strong>Expansion</strong></p>

<p>We can also add a &lsquo;Unlike&rsquo; function with a &lsquo;Thumbs-down&rsquo; button.
Instead of <code>like: true</code> params, we set it to false. In order to show the total likes, we add a method called <code>total_likes</code> in post.rb.</p>

<p>```ruby
def total_likes</p>

<pre><code>self.likes.where(like: true).size - self.likes.where(like :false).size
</code></pre>

<p>end
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Notes: Adding Categories]]></title>
    <link href="http://voice.lawrencesun.info/posts/2014/02/11/rails-notes-adding-categories/"/>
    <updated>2014-02-11T20:23:51+08:00</updated>
    <id>http://voice.lawrencesun.info/posts/2014/02/11/rails-notes-adding-categories</id>
    <content type="html"><![CDATA[<p>In the third note, a brief description about adding categories in a blog-like app will be presented. It is a <a href="http://guides.rubyonrails.org/association_basics.html">M-M relationship</a>. We will  apply <code>has_many :through</code> association.</p>

<!-- more -->


<p><strong>Migration</strong>:</p>

<p>```ruby
class CreatePostCategories &lt; ActiveRecord::Migration
  def up</p>

<pre><code>create_table :post_categories do |t|
    t.integer :post_id, :category_id

    t.timestamps
end
</code></pre>

<p>  end</p>

<p>  def down</p>

<pre><code>drop_table :post_categories
</code></pre>

<p>  end
end
```
PostCategories will have two foreign keys: :post_id and :category_id</p>

<p><strong>Models</strong>:</p>

<p>```ruby
class PostCategory &lt; ActiveRecord::Base</p>

<pre><code>belongs_to :post
belongs_to :category
</code></pre>

<p>end
```</p>

<p>```ruby
class Category &lt; ActiveRecord::Base</p>

<pre><code>has_many :post_categories
has_many :posts, through: :post_categories
...
</code></pre>

<p>end
```</p>

<p>```ruby
class Post &lt; ActiveRecord::Base</p>

<pre><code>...
has_many :post_categories
has_many :categories, through: :post_categories
...
</code></pre>

<p>end
```</p>

<p><strong>Controller and routes</strong></p>

<p>similar to other resources.</p>

<p><strong>Views</strong></p>

<p>&lsquo;shared/_posts.html.erb&rsquo;
```ruby
&lt;% object.reverse.each do |post| %></p>

<pre><code>&lt;p&gt;
    &lt;span class="badge pull-right"&gt;&lt;%= post.comments.count %&gt;&lt;/span&gt;
    &lt;%= link_to "#{post.title}", post_path(post) %&gt;&lt;br&gt;
    &lt;% post.categories.each do |category| %&gt;
    &lt;%= link_to category.name, category_path(category), class: "label" %&gt;
  &lt;% end %&gt;
  &lt;span class="timestamp"&gt;
        &lt;small&gt;posted by &lt;% unless post.user.blank? %&gt;
            &lt;%= link_to post.user.username, user_path(post.user) %&gt;
            &lt;% end %&gt;
            &lt;%= time_ago_in_words(post.created_at)%&gt; ago 
        &lt;/small&gt;
    &lt;/span&gt;
    &lt;hr&gt;
&lt;/p&gt;
</code></pre>

<p>&lt;% end %>
```</p>

<p>&lsquo;app/views/categories/show.html.erb&rsquo;
<code>ruby
...
&lt;%= render 'shared/posts', object: @category.posts %&gt;
...
</code></p>

<p>Add categories selection in _form partial
```ruby</p>

<div class='control-group'>
  <%= f.label "选择节点" %>
  <%= f.select :category_ids, Category.all.collect{|c| [c.name, c.id]}, {}, {multiple: false} %>
</div>


<p>```</p>

<p>Add get_categories method in ApplicationController to show categories in header.
```ruby
def get_categories</p>

<pre><code>@categories = Category.all
</code></pre>

<p>end</p>

<p>before_action :get_categories</p>

<p>&lt;% @categories.each do |cat| %>
<li>&lt;%= link_to cat.name, category_path(cat) %></li>  <br/>
&lt;% end %>
```</p>
]]></content>
  </entry>
  
</feed>
